提升性能
=====================

字节码缓存
--------------

强烈建议使用像APC这样的字节码缓存。字节码缓存消除了在每个请求上解析PHP代码的需要，并且可以极大地提高性能。

    “如果你关心性能并且不使用字节码缓存，那么你并不是真正关心性能。请获取一个并开始使用它。”

    *Stas Malyshev, Core Contributor to PHP and Zend Employee*

元数据和查询缓存
-------------------------

正如前面在配置Doctrine的章节中已经提到的，强烈建议不要使用没有元数据和查询缓存的Doctrine（最好使用
``APC`` 或 ``Memcache`` 作为缓存驱动）。
没有这些缓存的Doctrine操作意味着Doctrine需要在每个请求上加载映射信息，并且必须在每个请求上解析每个DQL查询。这是浪费资源。

备用的查询结果格式
--------------------------------

有效利用可用的替代查询结果格式，如嵌套数组图表或纯标量结果，尤其是在为只读目的而加载数据的情况下。

只读实体
------------------

从Doctrine2.1开始，你可以将实体标记为只读（有关详细信息，请参阅 *元数据映射引用*）。
这意味着标记为只读的实体永远不会考虑更新，这意味着当你在
``EntityManager`` 上调用 ``flush`` 时，即使有属性发生更改，也会跳过这些实体。
只读是一种允许持久新的实体并删除现有的实体的方式，它们只是不考虑更新。

超级延迟集合
----------------------

如果实体持有对大型集合的引用，则会在初始化时遇到性能和内存问题。
要解决此问题，你可以对集合使用 ``EXTRA_LAZY`` 提取模式功能。有关此提取模式如何工作的更多信息，请参阅
:doc:`教程 <../tutorials/extra-lazy-associations>`。

临时更改DQL中的提取模式
------------------------------------

请参阅：:ref:`Doctrine查询语言 <dql-temporarily-change-fetch-mode>`

应用最佳实践
--------------------

最佳实践章节中提到的许多要点也会对Doctrine的表现产生积极影响。

变更跟踪政策
------------------------

请参阅：:doc:`变更跟踪政策 <reference/change-tracking-policies>`。
